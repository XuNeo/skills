#!/usr/bin/env python3
"""Post comments to Gerrit review changes.

Self-contained, no external dependencies except python-gerrit-api.
"""
from __future__ import annotations

import argparse
import json
import sys

from gerrit import GerritClient
from requests import HTTPError

from gerrit_utils import GerritError, parse_change_url, get_config


def build_review_input(
    message: str | None = None,
    tag: str | None = None,
    labels: dict[str, int] | None = None,
    comments: dict[str, list[dict]] | None = None,
) -> dict:
    """Build ReviewInput entity for Gerrit API.

    Args:
        message: Overall review message.
        tag: Tag for the review (e.g., 'autogenerated:ci').
        labels: Vote labels as {label_name: vote_value}.
        comments: Inline comments as {file_path: [CommentInput, ...]}.

    Returns:
        ReviewInput dictionary ready for revision.set_review().
    """
    result: dict = {}

    if message is not None:
        result["message"] = message

    if tag is not None:
        result["tag"] = tag

    if labels is not None:
        result["labels"] = labels

    if comments is not None:
        result["comments"] = comments

    return result


def build_comment_input(
    message: str,
    line: int | None = None,
    range_: dict | None = None,
    in_reply_to: str | None = None,
    unresolved: bool | None = None,
    side: str = "REVISION",
) -> dict:
    """Build CommentInput entity for Gerrit API.

    Args:
        message: Comment message content.
        line: Line number (1-based) for inline comment.
        range_: Range dict with start_line, start_character, end_line, end_character.
        in_reply_to: Comment ID to reply to.
        unresolved: Whether comment requires attention. Defaults to True for new comments.
        side: REVISION or PARENT. Defaults to REVISION.

    Returns:
        CommentInput dictionary.
    """
    result: dict = {"message": message}

    if line is not None:
        result["line"] = line

    if range_ is not None:
        result["range"] = range_

    if in_reply_to is not None:
        result["in_reply_to"] = in_reply_to

    # Default unresolved to True for new comments (not replies)
    if unresolved is not None:
        result["unresolved"] = unresolved
    elif in_reply_to is None:
        result["unresolved"] = True

    if side != "REVISION":
        result["side"] = side

    return result


def post_review(
    base_url: str,
    change_ref: str,
    revision: str | None,
    review_input: dict,
) -> dict:
    """Post a review to Gerrit.

    Args:
        base_url: Gerrit server base URL.
        change_ref: Change number or Change-Id.
        revision: Target revision (SHA, patch set number, or 'current'). Defaults to 'current'.
        review_input: ReviewInput entity dictionary.

    Returns:
        API response result.

    Raises:
        GerritError: When API call fails.
    """
    _, username, password = get_config()
    client = GerritClient(
        base_url=base_url,
        username=username,
        password=password,
    )

    target_revision = revision or "current"

    try:
        change = client.changes.get(change_ref)
        rev = change.get_revision(target_revision)
        result = rev.set_review(review_input)
        return result if result else {}
    except HTTPError as e:
        status = e.response.status_code if e.response is not None else 0
        if status == 401:
            raise GerritError("Authentication failed (401)")
        if status == 404:
            raise GerritError("Change not found (404)")
        if status == 409:
            raise GerritError("Cannot post review to change edit (409)")
        if status == 403:
            raise GerritError("Permission denied (403)")
        raise GerritError(f"HTTP error: {e}")
    except Exception as e:
        raise GerritError(str(e))


def format_success_output(
    change_ref: str,
    revision: str | None,
    api_response: dict,
) -> dict:
    """Format successful operation output.

    Args:
        change_ref: Change number or Change-Id.
        revision: Target revision used.
        api_response: Response from Gerrit API.

    Returns:
        Formatted output dictionary.
    """
    return {
        "change": change_ref,
        "revision": revision or "current",
        "success": True,
        "response": api_response,
    }


def format_error_output(
    change_ref: str,
    revision: str | None,
    error: Exception,
) -> dict:
    """Format error output.

    Args:
        change_ref: Change number or Change-Id.
        revision: Target revision used.
        error: The exception that occurred.

    Returns:
        Formatted error output dictionary.
    """
    return {
        "change": change_ref,
        "revision": revision,
        "error": {
            "type": type(error).__name__,
            "message": str(error),
        },
    }


def main(argv: list[str] | None = None) -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Post comments to Gerrit review changes"
    )

    # Basic parameters
    parser.add_argument(
        "--change",
        required=True,
        help="Change URL, number, or Change-Id",
    )
    parser.add_argument(
        "--revision",
        help="Revision (SHA, patch set number, or 'current')",
    )
    parser.add_argument(
        "--message",
        help="Review message (overall comment)",
    )
    parser.add_argument(
        "--tag",
        help="Tag for the review (e.g., 'autogenerated:ci')",
    )

    # Inline comment parameters
    parser.add_argument(
        "--file",
        dest="file_path",
        help="File path for inline comment",
    )
    parser.add_argument(
        "--line",
        type=int,
        help="Line number for inline comment (1-based)",
    )
    parser.add_argument(
        "--range",
        dest="range_json",
        help='Range as JSON: {"start_line":1,"start_character":0,"end_line":5,"end_character":10}',
    )
    parser.add_argument(
        "--reply-to",
        dest="reply_to",
        help="Comment ID to reply to",
    )

    # Unresolved flag (mutually exclusive)
    resolved_group = parser.add_mutually_exclusive_group()
    resolved_group.add_argument(
        "--unresolved",
        action="store_true",
        default=None,
        help="Mark comment as unresolved (default for new comments)",
    )
    resolved_group.add_argument(
        "--resolved",
        action="store_true",
        help="Mark comment as resolved",
    )

    # Vote labels
    parser.add_argument(
        "--labels",
        dest="labels_json",
        help='Labels as JSON: {"Code-Review": 1, "Verified": 1}',
    )

    # Batch comments
    parser.add_argument(
        "--comments-json",
        dest="comments_json",
        help="JSON string or @file with batch comments",
    )

    args = parser.parse_args(argv)

    change = args.change.strip()
    revision = args.revision.strip() if args.revision else None

    try:
        # Determine base_url and change_ref
        if change.startswith(("http://", "https://")):
            base_url, change_ref = parse_change_url(change)
        else:
            base_url, _, _ = get_config()
            change_ref = change

        # Parse JSON arguments
        labels = None
        if args.labels_json:
            labels = json.loads(args.labels_json)

        range_dict = None
        if args.range_json:
            range_dict = json.loads(args.range_json)

        # Determine unresolved flag
        unresolved = None
        if args.unresolved:
            unresolved = True
        elif args.resolved:
            unresolved = False

        # Build comments if inline comment parameters provided
        comments = None
        if args.file_path:
            comment_input = build_comment_input(
                message=args.message or "",
                line=args.line,
                range_=range_dict,
                in_reply_to=args.reply_to,
                unresolved=unresolved,
            )
            comments = {args.file_path: [comment_input]}
            # Clear message if it was used for inline comment
            review_message = None
        else:
            review_message = args.message

        # Handle batch comments JSON
        if args.comments_json:
            batch_data = _load_comments_json(args.comments_json)
            # Merge batch data
            if "message" in batch_data and not review_message:
                review_message = batch_data["message"]
            if "tag" in batch_data and not args.tag:
                args.tag = batch_data["tag"]
            if "labels" in batch_data and not labels:
                labels = batch_data["labels"]
            if "comments" in batch_data:
                comments = batch_data["comments"]

        # Build review input
        review_input = build_review_input(
            message=review_message,
            tag=args.tag,
            labels=labels,
            comments=comments,
        )

        # Post review
        api_response = post_review(base_url, change_ref, revision, review_input)
        result = format_success_output(change_ref, revision, api_response)

    except json.JSONDecodeError as e:
        result = format_error_output(change, revision, GerritError(f"Invalid JSON: {e}"))
        json.dump(result, sys.stdout, ensure_ascii=False, indent=2)
        print()
        return 1
    except GerritError as e:
        result = format_error_output(change, revision, e)
        json.dump(result, sys.stdout, ensure_ascii=False, indent=2)
        print()
        return 1

    json.dump(result, sys.stdout, ensure_ascii=False, indent=2)
    print()
    return 0


def _load_comments_json(value: str) -> dict:
    """Load comments JSON from string or file.

    Args:
        value: JSON string or @filepath.

    Returns:
        Parsed JSON dictionary.
    """
    if value.startswith("@"):
        filepath = value[1:]
        with open(filepath, "r", encoding="utf-8") as f:
            return json.load(f)
    return json.loads(value)


if __name__ == "__main__":
    sys.exit(main())
