#!/usr/bin/env python3
"""Property-based tests for post_comment.py.

Uses hypothesis for property-based testing.
Run with: pytest test_post_comment.py -v
"""
from __future__ import annotations

import pytest
from hypothesis import given, strategies as st, settings

from post_comment import (
    build_review_input,
    build_comment_input,
    format_success_output,
    format_error_output,
)
from gerrit_utils import GerritError


# =============================================================================
# Property Tests for build_review_input()
# =============================================================================

# Feature: gerrit-post-comment, Property 1: ReviewInput message construction
# Validates: Requirements 1.1
@settings(max_examples=100)
@given(st.text(min_size=1))
def test_review_input_message_property(message: str):
    """For any non-empty message string, build_review_input(message=msg)
    SHALL contain a 'message' key with the exact input string."""
    result = build_review_input(message=message)
    assert "message" in result
    assert result["message"] == message


# Feature: gerrit-post-comment, Property 6: ReviewInput labels construction
# Validates: Requirements 5.1
@settings(max_examples=100)
@given(st.dictionaries(
    keys=st.text(min_size=1, max_size=50),
    values=st.integers(min_value=-2, max_value=2),
    min_size=1,
))
def test_review_input_labels_property(labels: dict[str, int]):
    """For any non-empty dictionary of label names to integer vote values,
    build_review_input(labels=labels_dict) SHALL contain a 'labels' key
    with all input label-value pairs preserved."""
    result = build_review_input(labels=labels)
    assert "labels" in result
    assert result["labels"] == labels


# Feature: gerrit-post-comment, Property 7: ReviewInput tag construction
# Validates: Requirements 6.1
@settings(max_examples=100)
@given(st.text(min_size=1))
def test_review_input_tag_property(tag: str):
    """For any non-empty tag string, build_review_input(tag=tag_str)
    SHALL contain a 'tag' key with the exact input string."""
    result = build_review_input(tag=tag)
    assert "tag" in result
    assert result["tag"] == tag


# =============================================================================
# Unit Tests for build_review_input()
# =============================================================================

def test_review_input_empty():
    """Empty input should return empty dict."""
    result = build_review_input()
    assert result == {}


def test_review_input_combined():
    """Combined parameters should all be present."""
    result = build_review_input(
        message="Test message",
        tag="autogenerated:test",
        labels={"Code-Review": 1},
    )
    assert result["message"] == "Test message"
    assert result["tag"] == "autogenerated:test"
    assert result["labels"] == {"Code-Review": 1}


def test_review_input_with_comments():
    """Comments should be included when provided."""
    comments = {
        "src/main.py": [
            {"line": 10, "message": "Test comment"}
        ]
    }
    result = build_review_input(comments=comments)
    assert "comments" in result
    assert result["comments"] == comments


def test_review_input_none_values_excluded():
    """None values should not be included in result."""
    result = build_review_input(message="Test", tag=None)
    assert "message" in result
    assert "tag" not in result



# =============================================================================
# Property Tests for build_comment_input()
# =============================================================================

# Feature: gerrit-post-comment, Property 2: CommentInput file and line construction
# Validates: Requirements 2.1
@settings(max_examples=100)
@given(
    st.text(min_size=1),
    st.integers(min_value=1, max_value=10000),
)
def test_comment_input_line_property(message: str, line: int):
    """For any valid message and positive line number, build_comment_input()
    SHALL contain 'message' and 'line' with exact values."""
    result = build_comment_input(message=message, line=line)
    assert result["message"] == message
    assert result["line"] == line


# Feature: gerrit-post-comment, Property 3: CommentInput range construction
# Validates: Requirements 2.2
@settings(max_examples=100)
@given(
    st.text(min_size=1),
    st.integers(min_value=1, max_value=1000),
    st.integers(min_value=0, max_value=100),
    st.integers(min_value=1, max_value=1000),
    st.integers(min_value=0, max_value=100),
)
def test_comment_input_range_property(
    message: str,
    start_line: int,
    start_char: int,
    end_line: int,
    end_char: int,
):
    """For any valid range, build_comment_input() SHALL contain a 'range' key
    with all four fields matching the input."""
    # Ensure valid range (start <= end)
    if start_line > end_line:
        start_line, end_line = end_line, start_line
    if start_line == end_line and start_char > end_char:
        start_char, end_char = end_char, start_char
    
    range_dict = {
        "start_line": start_line,
        "start_character": start_char,
        "end_line": end_line,
        "end_character": end_char,
    }
    result = build_comment_input(message=message, range_=range_dict)
    assert "range" in result
    assert result["range"]["start_line"] == start_line
    assert result["range"]["start_character"] == start_char
    assert result["range"]["end_line"] == end_line
    assert result["range"]["end_character"] == end_char


# Feature: gerrit-post-comment, Property 4: CommentInput reply construction
# Validates: Requirements 3.1
@settings(max_examples=100)
@given(st.text(min_size=1), st.text(min_size=1, max_size=100))
def test_comment_input_reply_property(message: str, comment_id: str):
    """For any comment ID, build_comment_input() SHALL contain 'in_reply_to'
    with the exact input ID."""
    result = build_comment_input(message=message, in_reply_to=comment_id)
    assert "in_reply_to" in result
    assert result["in_reply_to"] == comment_id


# Feature: gerrit-post-comment, Property 5: CommentInput unresolved flag handling
# Validates: Requirements 4.1, 4.2, 4.3
@settings(max_examples=100)
@given(st.text(min_size=1), st.booleans())
def test_comment_input_unresolved_explicit_property(message: str, unresolved: bool):
    """For any explicit boolean value for unresolved, build_comment_input()
    SHALL contain 'unresolved' with the exact boolean value."""
    result = build_comment_input(message=message, unresolved=unresolved)
    assert "unresolved" in result
    assert result["unresolved"] == unresolved


# =============================================================================
# Unit Tests for build_comment_input()
# =============================================================================

def test_comment_input_default_unresolved_new_comment():
    """New comments (not replies) should default unresolved to True."""
    result = build_comment_input(message="Test")
    assert result["unresolved"] is True


def test_comment_input_reply_no_default_unresolved():
    """Replies should not have default unresolved (inherit from parent)."""
    result = build_comment_input(message="Test", in_reply_to="abc123")
    assert "unresolved" not in result


def test_comment_input_file_level():
    """File-level comment (no line or range) should work."""
    result = build_comment_input(message="File comment")
    assert result["message"] == "File comment"
    assert "line" not in result
    assert "range" not in result


def test_comment_input_side_parent():
    """Side=PARENT should be included in result."""
    result = build_comment_input(message="Test", side="PARENT")
    assert result["side"] == "PARENT"


def test_comment_input_side_revision_default():
    """Side=REVISION (default) should not be included in result."""
    result = build_comment_input(message="Test")
    assert "side" not in result



# =============================================================================
# Property Tests for Output Format
# =============================================================================

# Feature: gerrit-post-comment, Property 9: Output format consistency
# Validates: Requirements 8.1, 8.2, 8.3
@settings(max_examples=100)
@given(
    st.text(min_size=1, max_size=50),
    st.one_of(st.none(), st.text(min_size=1, max_size=20)),
    st.dictionaries(st.text(min_size=1, max_size=20), st.text(max_size=50)),
)
def test_success_output_format_property(
    change_ref: str,
    revision: str | None,
    api_response: dict,
):
    """For any successful operation, output SHALL be valid JSON containing
    'change', 'success', and 'response' keys."""
    result = format_success_output(change_ref, revision, api_response)
    
    # Must have required keys
    assert "change" in result
    assert "success" in result
    assert "response" in result
    
    # Values must match
    assert result["change"] == change_ref
    assert result["success"] is True
    assert result["response"] == api_response
    
    # Revision should be present
    assert "revision" in result


@settings(max_examples=100)
@given(
    st.text(min_size=1, max_size=50),
    st.one_of(st.none(), st.text(min_size=1, max_size=20)),
    st.text(min_size=1, max_size=100),
)
def test_error_output_format_property(
    change_ref: str,
    revision: str | None,
    error_message: str,
):
    """For any error, output SHALL be valid JSON containing 'change' and
    'error' with 'type' and 'message' subkeys."""
    error = GerritError(error_message)
    result = format_error_output(change_ref, revision, error)
    
    # Must have required keys
    assert "change" in result
    assert "error" in result
    
    # Error must have type and message
    assert "type" in result["error"]
    assert "message" in result["error"]
    
    # Values must match
    assert result["change"] == change_ref
    assert result["error"]["type"] == "GerritError"
    assert result["error"]["message"] == error_message


# =============================================================================
# Unit Tests for Output Format
# =============================================================================

def test_success_output_default_revision():
    """Success output should default revision to 'current' when None."""
    result = format_success_output("12345", None, {})
    assert result["revision"] == "current"


def test_success_output_explicit_revision():
    """Success output should use explicit revision when provided."""
    result = format_success_output("12345", "3", {"labels": {}})
    assert result["revision"] == "3"


def test_error_output_preserves_revision():
    """Error output should preserve revision value (including None)."""
    result = format_error_output("12345", None, GerritError("test"))
    assert result["revision"] is None
    
    result = format_error_output("12345", "2", GerritError("test"))
    assert result["revision"] == "2"



# =============================================================================
# Property Tests for Batch Comments
# =============================================================================

# Strategy for generating valid CommentInput-like dicts
comment_input_strategy = st.fixed_dictionaries({
    "message": st.text(min_size=1, max_size=100),
}).map(lambda d: {**d, "unresolved": True})

# Strategy for generating batch comments structure
batch_comments_strategy = st.fixed_dictionaries({
    "message": st.one_of(st.none(), st.text(min_size=1, max_size=100)),
    "tag": st.one_of(st.none(), st.text(min_size=1, max_size=50)),
    "labels": st.one_of(
        st.none(),
        st.dictionaries(
            st.text(min_size=1, max_size=20),
            st.integers(min_value=-2, max_value=2),
            max_size=3,
        ),
    ),
    "comments": st.one_of(
        st.none(),
        st.dictionaries(
            st.text(min_size=1, max_size=50),  # file paths
            st.lists(comment_input_strategy, min_size=1, max_size=3),
            min_size=1,
            max_size=3,
        ),
    ),
})


# Feature: gerrit-post-comment, Property 8: Batch comments parsing round-trip
# Validates: Requirements 7.1
@settings(max_examples=100)
@given(batch_comments_strategy)
def test_batch_comments_roundtrip_property(batch_data: dict):
    """For any valid batch comments JSON structure, parsing and then
    building ReviewInput SHALL preserve all data."""
    import json as json_module
    
    # Filter out None values for comparison
    expected = {k: v for k, v in batch_data.items() if v is not None}
    
    # Simulate parsing JSON (round-trip through JSON)
    json_str = json_module.dumps(batch_data)
    parsed = json_module.loads(json_str)
    
    # Build ReviewInput from parsed data
    result = build_review_input(
        message=parsed.get("message"),
        tag=parsed.get("tag"),
        labels=parsed.get("labels"),
        comments=parsed.get("comments"),
    )
    
    # Verify all non-None values are preserved
    for key, value in expected.items():
        assert key in result, f"Key '{key}' missing from result"
        assert result[key] == value, f"Value mismatch for '{key}'"


# =============================================================================
# Unit Tests for Batch Comments
# =============================================================================

def test_batch_comments_full_structure():
    """Full batch structure should be correctly parsed."""
    batch_data = {
        "message": "Overall review",
        "tag": "autogenerated:test",
        "labels": {"Code-Review": 1},
        "comments": {
            "src/main.py": [
                {"message": "Comment 1", "line": 10},
                {"message": "Comment 2", "line": 20},
            ],
            "src/utils.py": [
                {"message": "Comment 3", "line": 5},
            ],
        },
    }
    
    result = build_review_input(
        message=batch_data["message"],
        tag=batch_data["tag"],
        labels=batch_data["labels"],
        comments=batch_data["comments"],
    )
    
    assert result["message"] == "Overall review"
    assert result["tag"] == "autogenerated:test"
    assert result["labels"] == {"Code-Review": 1}
    assert len(result["comments"]) == 2
    assert len(result["comments"]["src/main.py"]) == 2
    assert len(result["comments"]["src/utils.py"]) == 1


def test_batch_comments_partial_structure():
    """Partial batch structure (only comments) should work."""
    batch_data = {
        "comments": {
            "file.py": [{"message": "Test", "line": 1}],
        },
    }
    
    result = build_review_input(comments=batch_data["comments"])
    
    assert "message" not in result
    assert "tag" not in result
    assert "labels" not in result
    assert "comments" in result
